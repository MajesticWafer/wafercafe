<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Asteroids with Nebula and Particles</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

<script>
    // Setup scene, camera, and renderer using Three.js
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000); // Lower FOV for cinematic feel
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting setup
    const ambientLight = new THREE.AmbientLight(0x303030, 1.5); // Softer ambient light
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7).normalize(); // Slightly softer directional light
    scene.add(directionalLight);

    // Create the physics world using Cannon.js
    const world = new CANNON.World();
    world.gravity.set(0, 0, 0); // No gravity, space-like

    // Array to store asteroid meshes and bodies
    const asteroids = [];
    const asteroidBodies = [];
    const particles = [];

    // Darker asteroid material with rough surface
    const asteroidMaterial = new THREE.MeshStandardMaterial({
        color: 0x444444,  // Dark gray rocky texture
        roughness: 1,     // Rough surface
        bumpScale: 0.4    // Emphasize the roughness for a more rocky look
    });

    // Procedural noise-based bump map for asteroid surface
    const textureLoader = new THREE.TextureLoader();
    const bumpMap = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg'); // Using noise texture for bumps
    asteroidMaterial.bumpMap = bumpMap;

    // Function to create oblong asteroids
    function createAsteroid() {
        const asteroidGeometry = new THREE.DodecahedronGeometry(Math.random() * 0.5 + 0.2, 1); // Irregular shape
        const asteroidMesh = new THREE.Mesh(asteroidGeometry, asteroidMaterial);

        // Scale randomly to create oblong effect
        asteroidMesh.scale.set(
            Math.random() * 2 + 0.5,
            Math.random() * 0.5 + 0.5,
            Math.random() * 1.5 + 0.5
        );

        // Random position in space
        asteroidMesh.position.set(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 10
        );
        scene.add(asteroidMesh);

        // Create corresponding physics body
        const asteroidShape = new CANNON.Sphere(asteroidGeometry.parameters.radius); // Simplified for physics
        const asteroidBody = new CANNON.Body({
            mass: 1,
            position: new CANNON.Vec3(
                asteroidMesh.position.x,
                asteroidMesh.position.y,
                asteroidMesh.position.z
            ),
            shape: asteroidShape,
        });

        // Random velocity for motion
        asteroidBody.velocity.set(
            (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 5,
            (Math.random() - 0.5) * 5
        );

        // Add asteroid to the world
        world.addBody(asteroidBody);
        asteroids.push({ mesh: asteroidMesh, body: asteroidBody });
    }

    // Create multiple asteroids
    for (let i = 0; i < 10; i++) {
        createAsteroid();
    }

    // Function to create particles (debris) when asteroids collide
    function createParticles(position) {
        const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const particleMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Bright yellow particles
        const particleMesh = new THREE.Mesh(particleGeometry, particleMaterial);

        particleMesh.position.copy(position);
        scene.add(particleMesh);
        particles.push(particleMesh);

        // Remove particle after some time
        setTimeout(() => {
            scene.remove(particleMesh);
        }, 500);  // Particles disappear after 0.5 seconds
    }

    // Add a nebula effect using a particle system
    function createNebula() {
        const nebulaGeometry = new THREE.BufferGeometry();
        const nebulaParticles = 1000;
        const positions = new Float32Array(nebulaParticles * 3); // XYZ for each particle

        for (let i = 0; i < nebulaParticles; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 50;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 50;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
        }

        nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const nebulaMaterial = new THREE.PointsMaterial({
            color: 0x8800ff,  // Purple nebula color
            size: 0.5,
            opacity: 0.5,
            transparent: true,
            depthWrite: false,
        });

        const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
        scene.add(nebula);
    }

    createNebula();  // Create nebula in the background

    // Handle asteroid collisions
    world.addEventListener('postStep', () => {
        asteroids.forEach(asteroid => {
            if (asteroid.body.velocity.lengthSquared() > 10) { // Detect collision impact
                createParticles(asteroid.mesh.position); // Add particles at collision point
            }
        });
    });

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);

        // Step the physics world
        world.step(1 / 60);

        // Update asteroid positions
        asteroids.forEach(asteroid => {
            asteroid.mesh.position.copy(asteroid.body.position);
            asteroid.mesh.quaternion.copy(asteroid.body.quaternion);
        });

        // Render the scene
        renderer.render(scene, camera);
    }

    // Set camera position
    camera.position.z = 15;

    // Start animation
    animate();

    // Handle window resizing
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });
</script>
</body>
</html>
