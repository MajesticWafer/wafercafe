<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Clone</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; image-rendering: pixelated; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="textures.js"></script> <!-- Texture management file -->
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    camera.up.set(0, 1, 0);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 20, 10).normalize();
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // Block Geometry and Instancing
    const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
    const instanceCount = 10000;  // Adjust based on your needs
    const instancedMesh = new THREE.InstancedMesh(blockGeometry, new THREE.MeshStandardMaterial(), instanceCount);
    scene.add(instancedMesh);

    let index = 0; // Track block instance count

    // Frustum Culling: Only add blocks within view
    const frustum = new THREE.Frustum();
    const cameraViewProjectionMatrix = new THREE.Matrix4();

    function isVisible(position) {
      const point = new THREE.Vector3(position.x, position.y, position.z);
      camera.updateMatrixWorld();
      cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
      return frustum.containsPoint(point);
    }

    // Generate terrain using Perlin noise
    const chunkSize = 48;
    const blocks = [];  // Block positions for chunking and collision

    function generateTerrainChunk() {
      for (let x = 0; x < chunkSize; x++) {
        for (let z = 0; z < chunkSize; z++) {
          const terrainHeight = Math.floor(perlin(x, z));

          for (let y = 0; y <= terrainHeight; y++) {
            const position = new THREE.Vector3(x, y, z);
            if (isVisible(position)) {  // Add only visible blocks
              const matrix = new THREE.Matrix4().makeTranslation(x, y, z);
              instancedMesh.setMatrixAt(index++, matrix);
            }

            blocks.push(position); // For collision
          }
        }
      }
    }

    generateTerrainChunk();
    instancedMesh.instanceMatrix.needsUpdate = true; // Ensure matrix updates

    // Player and controls (kept as original)

    // Create skybox (as original)

    function animate() {
      requestAnimationFrame(animate);
      updatePlayer();  // Update player position
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
