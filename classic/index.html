<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minecraft Clone</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; image-rendering: pixelated; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="textures.js"></script> <!-- Texture management file -->
  <script>
    // Setup scene, camera, and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;  // Enable shadows
    document.body.appendChild(renderer.domElement);
    
    // Lighting setup
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 20, 10).normalize();
    directionalLight.castShadow = true; // Enable shadow casting
    scene.add(directionalLight);

    // Create block geometry and material
    const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
    const dirtMaterial = new THREE.MeshStandardMaterial({ map: textures.dirt });
    const stoneMaterial = new THREE.MeshStandardMaterial({ map: textures.stone });
    const bedrockMaterial = new THREE.MeshStandardMaterial({ map: textures.bedrock });
    const woodMaterial = new THREE.MeshStandardMaterial({ map: textures.wood });
    const leafMaterial = new THREE.MeshStandardMaterial({ map: textures.leaf });

    // Generate a 16x16x3 chunk of blocks
    const chunkSize = 32;
    const chunkHeight = 7;
    const blocks = []; // Store block positions for collision detection

    function generateChunk() {
      for (let x = 0; x < chunkSize; x++) {
        for (let z = 0; z < chunkSize; z++) {
          for (let y = 0; y < chunkHeight; y++) {
            let material;
            if (y === 4) {
              material = createGrassBlockMaterial(); // Grass block on top
            } else if(y === 3) {
              material = dirtMaterial; // Dirt block below
            } else if(y < 3 && y > 0) {
              material = stoneMaterial; // Stone block below
            } else if(y === 0) {
              material = bedrockMaterial; // Bedrock block below
            }

            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x, y, z);
            block.castShadow = true;  // Enable block shadow casting
            block.receiveShadow = true;  // Enable block shadow receiving
            scene.add(block);
            blocks.push(block); // Add block to array for collision
          }
        }
      }
    }

    generateChunk();

    // Function to add a tree at a specific position
    function addTree(x, z) {
      // Tree trunk (wood blocks)
      for (let y = 5; y < 9; y++) {
        const woodBlock = new THREE.Mesh(blockGeometry, woodMaterial);
        woodBlock.position.set(x, y, z);
        woodBlock.castShadow = true;
        woodBlock.receiveShadow = true;
        scene.add(woodBlock);
      }

      // Leaves (leaf blocks)
      for (let dx = -1; dx <= 1; dx++) {
        for (let dz = -1; dz <= 1; dz++) {
          const leafBlock1 = new THREE.Mesh(blockGeometry, leafMaterial);
          leafBlock1.position.set(x + dx, 9, z + dz);
          leafBlock1.castShadow = true;
          leafBlock1.receiveShadow = true;
          scene.add(leafBlock1);

          if (Math.abs(dx) < 2 && Math.abs(dz) < 2) { // Create smaller layers
            const leafBlock2 = new THREE.Mesh(blockGeometry, leafMaterial);
            leafBlock2.position.set(x + dx, 8, z + dz);
            leafBlock2.castShadow = true;
            leafBlock2.receiveShadow = true;
            scene.add(leafBlock2);
          }
        }
      }
    }

    // Place the tree in the chunk at (10, 5)
    addTree(10, 5);

    // Skybox creation
    function createSkybox() {
      const skyGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
      const skyMaterials = [
        new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
        new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
        new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
        new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
        new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide }),
        new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide })
      ];
      const skybox = new THREE.Mesh(skyGeometry, skyMaterials);
      scene.add(skybox);
    }
    createSkybox();

    // Main animation loop
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
