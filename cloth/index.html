<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js Cloth Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

  // Scene setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 2, 5);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
  const pointLight = new THREE.PointLight(0xffffff, 1);
  pointLight.position.set(5, 5, 5);
  scene.add(ambientLight, pointLight);

  // Cloth geometry
  const segments = 4; // 4 x 4 = 16 polys
  const geometry = new THREE.PlaneGeometry(4, 4, segments, segments);
  const material = new THREE.MeshStandardMaterial({
    color: 0x0077ff,
    side: THREE.DoubleSide,
    wireframe: true,
  });
  const cloth = new THREE.Mesh(geometry, material);
  cloth.rotation.x = -Math.PI / 2;
  scene.add(cloth);

  // Cloth physics
  const positions = geometry.attributes.position.array;
  const originalPositions = [...positions];
  const velocities = new Array(positions.length).fill(0);

  const gravity = -0.02;
  const stiffness = 0.1;
  const damping = 0.98;

  function simulateCloth() {
    for (let i = 0; i < positions.length; i += 3) {
      if (i === 0 || i === segments * 3) continue; // Pin top corners
      const dx = originalPositions[i] - positions[i];
      const dy = originalPositions[i + 1] - positions[i + 1];
      const dz = originalPositions[i + 2] - positions[i + 2];
      
      velocities[i] += stiffness * dx;
      velocities[i + 1] += stiffness * dy + gravity;
      velocities[i + 2] += stiffness * dz;

      velocities[i] *= damping;
      velocities[i + 1] *= damping;
      velocities[i + 2] *= damping;

      positions[i] += velocities[i];
      positions[i + 1] += velocities[i + 1];
      positions[i + 2] += velocities[i + 2];
    }
    geometry.attributes.position.needsUpdate = true;
  }

  // Interaction
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  let dragging = false, dragIndex = null;

  function onPointerMove(event) {
    pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
    pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

    if (dragging && dragIndex !== null) {
      raycaster.setFromCamera(pointer, camera);
      const intersect = raycaster.intersectObject(cloth);
      if (intersect.length > 0) {
        const point = intersect[0].point;
        positions[dragIndex] = point.x;
        positions[dragIndex + 1] = point.y;
        positions[dragIndex + 2] = point.z;
      }
    }
  }

  function onPointerDown(event) {
    raycaster.setFromCamera(pointer, camera);
    const intersect = raycaster.intersectObject(cloth);
    if (intersect.length > 0) {
      dragging = true;
      const index = intersect[0].face.a * 3; // Pick a vertex
      dragIndex = index;
    }
  }

  function onPointerUp() {
    dragging = false;
    dragIndex = null;
  }

  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointerup', onPointerUp);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    simulateCloth();
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
